const o=new Map,a=new Map;self.onconnect=e=>{const s=e.ports[0];s.onmessage=t=>{d(s,t.data)},s.start()};function d(e,s){switch(s.type){case"register":f(e,s.data);break;case"send":g(e,s.data);break;case"unregister":l(e);break}}function f(e,s){const{sessionId:t}=s,i=!a.get(t);if(o.set(e,{port:e,sessionId:t,isMain:i}),i){const r=p(t);a.set(t,r)}e.postMessage({type:"registered",data:{isMain:i}})}function g(e,s){const t=o.get(e);if(!t)return;const n=a.get(t.sessionId);n&&n.readyState===WebSocket.OPEN&&n.send(JSON.stringify(s))}function l(e){const s=o.get(e);if(!s)return;o.delete(e);const t=Array.from(o.values()).filter(n=>n.sessionId===s.sessionId);if(t.length===0){const n=a.get(s.sessionId);n&&(n.close(),a.delete(s.sessionId))}else if(s.isMain){const n=t[0];n.isMain=!0,n.port.postMessage({type:"promoted",data:{isMain:!0}})}}function p(e){const s=self.location.protocol==="https:"?"wss:":"ws:",t=new WebSocket(`${s}//${self.location.host}/ws/${e}`);return t.onmessage=n=>{const i=JSON.parse(n.data);c(e,{type:"message",data:i})},t.onclose=()=>{c(e,{type:"disconnected"}),a.delete(e)},t.onerror=()=>{c(e,{type:"error",data:"WebSocket error"})},t}function c(e,s){o.forEach(t=>{t.sessionId===e&&t.port.postMessage(s)})}
